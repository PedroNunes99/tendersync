---------------------------- section ----------------------------
docs
---------------------------- document_id ----------------------------
1683
---------------------------- title ----------------------------
Custom Metric Collection
---------------------------- permalink ----------------------------
custom-metric-collection
---------------------------- keywords ----------------------------
agent metric custom
---------------------------- body ----------------------------
<a name="Overview"></a>
## Overview
The New Relic agent has an API that allows an application to collect custom metrics. Custom metrics are used to augment the data that RPM already collects and are most useful when applied to areas of your application that you know are important.

Metrics are streams of data about "interesting things". For example, RPM collects a metric for the amount of CPU that the current process is burning. It also collects a metric that tracks every Controller action invocation. However, the out of the box metrics can only go so far. This is where custom metrics are useful. For example, at New Relic, one of the things we use custom metrics for is to collect detailed data about the Web Service that our agent talks to. We also collect customer metrics that tell us the annualized value of our current subscriptions.

Custom metrics are visible in a few places in RPM. These are:

* Transaction views in RPM Developer Mode
* Breakdown graphs on the Controller page 
* The Details tab of a Transaction Trace
* Custom Dashboards, where any metric (including business metrics) can be shown on a user created dashboard

NOTE: Collecting too many metrics can impact the performance of your application and of RPM. New Relic reserves the right to disable accounts which collect excessive metrics. For example, it's a bad idea to create metrics that track each individual user on your site - this could result in thousands or millions of metrics.

<a name="Method_Tracers"></a>
## Collecting custom metrics with Method Tracers
A Method Tracer is a software probe that you can put on a method of any ruby class. Method Tracers must be applied after the target method has been defined. The probe uses alias method chaining to insert itself into the executing of the target method.

To add a Method Tracer within a class use the following ruby statement:

	add_method_tracer <method_name>, <metric_name>, <options>

For example, to add a method tracer to <code>MemCache#get</code>, do the following:

	MemCache.class_eval do
  		add_method_tracer :get, 'MemCache/read'
	end

Method tracers can also be used within normal class definition, just make sure that the target method has been defined. 

For example:

	class Foo
		...
		def generate_image
		...
		end
	
		add_method_tracer :generate_image, 'Custom/generate_image'
	end

### Metric Names
Metric names are paths delimited by the "/" character. One convention used in RPM is:

	<category>/<class>/<method>

Reserved categories include:

* ActiveRecord
* Apdex
* CPU
* Controller
* Database
* Memory
* View

For custom metrics, you are free to pick your own metric names, however the recommend convention is:

	Custom/<class>/<method> or Custom/<category>/<name>



### Options
The <code>add_method_tracer</code> statement takes a hash of options as the last parameter. The options are:

#### :metric => <true|false> (default == true)
This option tells the agent whether to produce a metric. If false, no metric is produced but the tracer does insert an element into Transaction Traces. Producing a metric adds more overhead to the application than not producing a metric.

#### :push_scope => <true|false> (default == true)
This option tells the agent whether the metric should be scoped to the calling controller action. Scoped metrics show up in controller breakdown charts and Transaction Traces. Global metrics are visible from Custom Dashboards (Gold Subscription Required) and are well suited to summary data that applies across controller actions. Every scoped metric also produces a global "roll-up" metric (see The Gritty Details section below for more info on global metrics). For example, a <code>Memcache#get</code> method tracer will produce one metric for each unique controller action and one global roll-up metric. Scoped metrics add more overhead to the application than global metrics.

#### :scoped_metric_only => <true|false> (default == false)
This option tells the agent whether the metric should be scoped only and not produce an automatic roll-up metric. Producing an automatic roll-up metric adds more overhead to the application than not producing an automatic roll-up.

<a name="Non_Method_Tracer_Metrics"></a>
## Non Method Tracer Metrics
It is possible to collect metric data about things other than method invocations. To do this, you'll need to manipulate metric data directly.

First, get a handle to a <code>Stat</code> instance by making the following API call:

	
	stat = NewRelic::Agent.agent.stats_engine.get_stats_no_scope(<String:metric_name>)


Second, update the stat with the data. This increments the <code>Stat.call_count</code> field and adds the value to the <code>Stat.total_call_time</code> fields (see The Gritty Details section below).

	stat.record_data_point(<Float:value>)

Here's an easy example that shows how you might use metrics to track dollars flowing through a site:

	class Cart
		@@its_business_time = 
			NewRelic::Agent.agent.stats_engine.get_stats_no_scope('Custom/Cart/charge_amount')
		
		def checkout()
			amount = compute_cart_total		# computes the amount to charge the customer
			
			@@its_business_time.record_data_point(amount)
			
			charge_customer(amount)
			...
		end
	end

		
To lean more about how data aggregates over time, check out the Stat Aggregation Policy section below.


<a name="The_Gritty_Details"></a>
## The Gritty Details - Metrics & Stats
There are two basic data structures used for collecting metric data. The first is a <code>Metric</code> and the second is a <code>Stat</code>. 

A <code>Metric</code> describes the thing for which we have data. The following pseudo Ruby shows how it is defined:

	class Metric
		attr_accessor :name    # String - metric name
		attr_accessor :scope   # String - current controller action
	end

It's a pretty simple structure. The name gives details about the "thing" we have data for. The optional scope is the name of the controller action handling the current request. A metric is "global" if the scope is empty.

A <code>Stat</code> is a class used to record data about a metric. Stats are geared towards collecting data about method execution, however the fields can be overridden to store data about anything. The following pseudo Ruby defines a Stat:

	class Stat
		attr_accessor :call_count           # Integer - method invocation count
		attr_accessor :total_call_time      # Float - total method call time (in seconds)
		attr_accessor :total_exclusive_time # Float - total time spent in the traced method minus any child time (in seconds)
		attr_accessor :min_call_time        # Float - the smallest method invocation time (in seconds)
		attr_accessor :max_call_time        # Float - the largest method invocation time (in seconds)
		attr_accessor :sum_of_squares       # Float - the sum of squares of response times - used for standard deviation computation
		attr_accessor :begin_time           # Time - the start of the time window for this data
		attr_accessor :end_time             # Time - end of the time window for this data
	end


### Stat Aggregation Policy
One of the strengths of RPM is its ability to aggregate data over time. The aggregation policy can be important to know when collecting custom metrics. Aggregation is an act of combining several things into one. The aggregation policy for each field is:

* <code>call_count</code> - addition
* <code>total_call_time</code> - addition
* <code>total_exclusive_time</code> - addition
* <code>min_call_time</code> - the min() of each min_call_time
* <code>max_call_time</code> - the max() of each max_call_time
* <code>sum_of_squares</code> - addition
* <code>begin_time</code> - the min() of each begin_time
* <code>end_time</code> - the max() of each end_time
